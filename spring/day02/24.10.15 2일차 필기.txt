1. 스프링 답게 작업하기
 - MemberController가 생성될 때, 생성자 호출해준다.
   즉, service까지 생성해서 자동으로 호출해준다. 
 - @Autowired를 선언해주면 MemberController를 생성하면서 스프링이 memberService와 연결을 해준다.
 - 서버 기동 시, 연결 해당 작업이 일어난다.
	-> 서버 기동 시, 연결 실패 시에 에러가 발생한다.
	-> 기존은 테스트를 통해서만 service가 오류가 나는 것을 확인할 수 있었다. 
 - 생성자에 @Autowired가 있으면 스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 넣어준다.
 - 이렇게 객체 의존관계를 외부에서 넣어주는 것을 DI(Dependency Injection), 의존성 주입이라고 한다.
 - 이전에서는 개발자가 직접 주입했고, 여기서는 @Autowired에 의해 스프링이 주입해준다.

2. 제어의 역전(Ioc, Inversion of Control)
 - 개발자가 프레임워크의 기능을 호출하는 형태가 아니라, 프레임워크가 개발자의 코드를 호출하기 때문에, 개발자는 전체를 직접 구현하지 않고 자신의 코드를 부분적으로 "끼워넣기" 하는 형태로 구현할 수 있다.
   이는 개발자로 하여금 구현하고자하는 특정 분야의 기능에 집중할 수 있도록 한다.
 - 프레임워크가 객체의 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수도 있다.
 - 객체의 의존성을 역전시켜 객체간의 결합도를 줄이고, 유연한 코드를 작성할 수 있게 하여 가독성 및 코드 중복, 유지 보수를 편하게 할 수 있게 한다. 

3. 스프링 컨테이너란?
 - 스프링 컨테이너는 자바 객체의 생명 주기를 관리하며, 생성된 자바 객체들에게 추가적인 기능을 제공하는 역할을 한다.
 - 여기서 말하는 자바 객체를 스프링에서는 빈(Bean)이라고 부른다.
 - 개발자는 객체를 생성하고 소멸할 수 있는데, 스프링 컨테이너가 이 역할을 대신해준다.
   즉, 제어의 흐름을 외부에서 관리하는 것.
 - 스프링은 실행 시, 객체들을 담고있는 Container가 있다. 

4. @Autowired
 - 필요한 의존 객체의 "타입"에 해당하는 빈을 찾아 주입한다.
 - 그리고 Autowired는 기본값이 true이기 때문에 의존성 주입을 할 대상을 찾지 못한다면 애플리케이션 구동에 실패한다.

5. POJO
 - Plain Old Java Object, 단순한 자바 오브젝트
 - POJO란, 객체 지향적인 원리에 충실하면서 환경과 기술에 종속되지 않고 필요에 따라 재활용 될 수 있는 방식으로 설계된 오브젝트를 말한다.
 - 그러한 POJO에 애플리케이션의 핵심 로직과 기능을 담아 설계하고 개발하는 방법을 POJO프로그래밍 이라고 할 수 있다.

6. 참고
 - 스프링은 스프링 컨테이너에 스프링 빈을 등록할 때, 기본으로 싱글톤으로 등록한다. (유일하게 하나만 등록해서 공유한다.)
 - 따라서 같은 스프링 빈이면 모두 같은 인스턴스다. 

7. 컴토넌트 스캔의 대상
 - Component scan의 대상은 main 메서드가 있는 class의 동일 패키지 또는 하위 패키지만 Spring이 scan을 하는 대상이된다.
   (당연히 설정을 통해서 다른 패키지의 클래스도 있지만)
 - @ComponentScan

8. DI(의존성 주입 : Dependency Injection)
 - 의존성 주입이란?
 - 객체간의 의존성이 존재할 경우 개발자가 직접 객체를 생성하거나 제어하는 것이 아니라, 제어반전에 의하여 특정 객체에 필요한 다른 객체를 프레임워크가 자동으로 연결시켜 주는 것을 말한다.
 - 개발자는 자신에게 필요한 객체를 직접 할당하지 않고, 인터페이스를 통해 선언한 객체에 스프링 프레임워크에 의해 주입받아 사용할 수 있기 때문에 비즈니스 로직 개발에만 집중할 수 있다.
 - 개발자는 객체를 선언만 할 뿐, 할당은 프레임워크에 의해서 자동으로 이루어진다. 

9. DI의 3가지 방법
 - Field Injection(필드 주입)
 - Setter Injection(수정자 주입)
 - Constructor Injection(생성자 주입)

10. SOLID
 - 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리
 - SRP : 단일책임 원칙(Single responsibility principle)
 - OCP : 개방-폐쇄 원칙(Open/Closed principle)
 - LSP : 리스코프 치환 원칙(Liskov substitution principle)
 - ISP : 인터페이스 분리원칙(Interface segregation principle)
 - DIP : 의존관계 역전 원칙(Dependency inversion principle)

 10-1. SRP : 단일책임 원칙(Single responsibility principle)
   - 한 클래스는 하나의 책임만 가져야 한다.
   - 하나의 책임이라는 것은 모호하다.
   - 클 수 있고, 작을 수 있다. 
   - 문맥과 상황에 따라 다르다.
   - 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.
   - 예) UI 변경, 객체의 생성과 사용을 분리

 10-2. OCP : 개방-폐쇄 원칙(Open/Closed principle)
   - 확장에는 열려있고, 수정, 변경에는 닫혀있다. 

 10-3. LSP : 리스코프 치환 원칙(Liskov substitution principle)
   - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
   - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것이다.
   - 다형성을 지원하기 위한 원칙,
   - 인터페이스를 구현한 구현체는 믿고 사용하려면 이 원칙이 필요하다.
   - 단순히 컴파일에 성공하는 것을 넘어서는 이야기이다.
   - 예) 자동차 인터페이스에서 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야한다.

 10-4. ISP : 인터페이스 분리원칙(Interface segregation principle)
   - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
   - 인터페이스가 명확해야 하고, 대체 가능성이 높아진다.

 10-5. DIP : 의존관계 역전 원칙(Dependency inversion principle)
   - 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나.
   - 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻이다. 
   - 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.

11. JPA
 - JPA는 기존의 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행해 준다.
 - JPA를 사용하면, SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환할 수 있다.
 - JPA를 사용하면 개발 생산성을 크게 높일 수 있다.

12. HTTP 요청 파라미터
 - 서블릿으로 학습했던 내용을 스프링이 얼마나 깔끔하고 효율적으로 바꾸어주는지 알아보자
 - HTTP 요청 메시지를 통해 클라이언트에서 서버로 데이터를 전달하는 방법을 알아보자
