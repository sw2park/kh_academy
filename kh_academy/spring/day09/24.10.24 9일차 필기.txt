1. 양방향 연관관계와 연관관계 주인(중요)
 - 현재 예제의 객체는 Member가 Team을 가졌으나, Team은 Member를 가지지 못한다.
 - 객체참조와 외래치의 가장 큰 차이점
 - 테이블은 FK만 있으면 양쪽에 연관관계를 알 수 있다.
 1-1. 양방향 매핑이 좋은가?
   - 가급적 단방향으로 처리. 
     필요에 따라서 양방향 매핑은 추가한다. 

2. 연관관계 주인
 2-1. 테이블 연관관계 = 1개
   - 회원 <->팀의 연관관계 1개(양방향)
   - 사실 FK만 잘 걸려있으면 양쪽으로 이동할 수 있다.
	-> MEMBER 테이블 입장에서 TEAM 테이블 조인 가능
	-> TEAM 테이블 입장에서 MEMBER 테이블 조인 가능
 2-2. 객체 연관관계 = 2개
   - 회원 -> 팀 연관관계 1개(단방향)
   - 팀 -> 회원 연관관계 1개(단방향)
	-> 사실은 단방향 연관관계가 2개 있는 것. (억지로 양방향 연관관계라고 말하는 것)
   - 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계가 2개이다.
   - 객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.
 2-3. 문제점
   - 둘 중 하나로 외래 키를 관리해야 한다.
   - Member 객체에서 Team으로 가는 team 참조 값과, Team에서 Member로 가는 members 참조 값이 있다.
   - Member에서는 Team 값이 수정 됐을 때, MEMBER table의 TEAM_ID가 수정이 되어야 하는지, 
     Team에 있는 members를 수정했을 때, MEMBER에 있는 TEAM_ID가 수정되야 하는지? 에 대한 딜레마가 생긴다.
   - DB입장에서는 MEMBER에 있는 TEAM_ID만 update되면 된다.
 2-4. 연관관계의 주인(Owner)
   - 양방향 매핑 규칙
   - 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
   - 연관관계의 주인만이 외래 키를 관리(등록, 수정)
   - 주인이 아닌 쪽은 읽기만 가능
   - 주인은 mappedBy 속성 사용X
     (내가 누군가에 의해서 mapping되어 있어)
   - 주인이 아니면 mappedBy 속성으로 주인을 지정
   - 누구를 주인으로? -> 답이 있다.
   - 외래키가 있는 곳을 주인으로 정한다.
 2-5. 양방향 연관관계 주의 사항
   - 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자. 
   - 연관관계 편의 메소드를 생성하자.
   - 양방향 매핑시에 무한 루프를 조심하자. 
     (예 : toString(), lombok, ...)
 2-6. 연관관계 편의 메소드 생성
   - N(다)에 넣기
   - 1(일)에 넣기
	=> 둘 중에 하나만 넣자. 둘 다 넣으면 무한루프가 걸리는 경우가 있다.

3. 양방향 매핑 정리
 - 단방향 매핑만으로도 이미 연관관계 매핑은 완료
 - 양방향 매핑은 반대 방향으로 조회 기능이 추가된 것 뿐
 - 양방향 사용 이유 : JPQL, QueryDSL에서 역방향으로 탐색할 일이 많음
 - 단방향 매핑을 잘 하고, 양방향은 필요할 때 추가해도 됨
   (테이블에 영향을 주지 않음)
 - 결론 : 객체 입장에서 양방향 매핑은 이득이 별로 되지 않는다.(필수가 아님)
   필요 시에 그때 생성해도 늦지않다. (옵션으로 넣을 것)

4. 연관관계 주인을 정하는 기준
 - 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
 - 연관관계의 주인은 외래 키의 위치를 기준으로 정해야한다.

5. 임베디드 타입
 5-1. 임베디드 타입이란?
   - 내장타입
   - 새로운 값 타입을 직접 정의할 수 있음
   - JPA는 임베디드 타입(embedded type)이라고 함
   - 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함
   - int, String과 같은 값 타입
 5-2. JPA에서 임베디드 타입 사용법
   - @Embeddable : 값 타입을 정의하는 곳에 표시
   - @Embedded : 값 타입을 사용하는 곳에 표시
   - 기본 생성자 필수
   - @Embedded 또는, @Embeddable 둘 중에 하나만 써도 기능은 된다. 그러나 둘다 넣는 것을 권장
 5-3. 임베디드 타입의 장점
   - 재사용
   - 높은 응집도
   - Period.isWork() 처럼 해당 값 타입만 사용하는 의미있는 메소드를 만들 수 있다.
     (객체지향적 설계가 가능하다.)
   - 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기에 의존한다. 
 5-4. 임베디드 타입과 테이블 매핑
   - DB입장에서는 바뀔게 없다. 객체 입장에서 mapping만 바뀔 뿐.
   - 테이블은 그대로 생성되었고, 좀 더 객체지향적으로 사용할 수 있다. 
 5-5. 임베디드 타입과 테이블 매핑
   - 임베디드 타입은 엔티티의 값일 뿐이다.
   - 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.
   - 객체와 테이블을 아주 세밀하게 매핑하는 것이 가능해진다.
   - 잘 설계된 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.
 5-6. @AttributeOverride : 속성 재정의
   - 한 엔티티에서 같은 값 타입을 사용한다면? -> 컬럼명이 중복된다.
   - @AttributeOverrrides, @AttributeOverride를 사용해서 컬럼 명 속성을 재정의
 5-7. 값 타입 복사
   - 값 타입의 실제 인스턴스인 값을 공유하는 것은 위험하다.
   - 대신 값(인스턴스)를 복사해서 사용