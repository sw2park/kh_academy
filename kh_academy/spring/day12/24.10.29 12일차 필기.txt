1. 컬럼명과 테이블 엔티티 필드명이 다른 이유
 - @Column 어노테이션을 지정하지 않고 private int orderPrice; 와 같은 필드명을 JPA엔티티에 사용하면, JPA는 기본적으로 Camel Case 형식의 필드명을 Snake Case 형식(_가 들어가는 형태)의 컬럼명으로 변환한다.
   따라서 orderPrice 필드는 데이터베이스에 order_price와 같은 형식으로 매핑된다.

2. 변경감지와 머지(merge) - 아이템 수정
 - 여기서 item 객체는 준영속 상태의 item이다.
 - 따라서 영속성 컨텍스트의 지원을 받을 수 없고, 데이터를 수정해도 변경 감지 기능은 동작할 수 없다.
 2-1. 준영속 상태란?
   - 준영속(detached)
   - 영속성 컨텍스트에 저장되었다가 분리된 상태로 현재는 영속 상태가 아닌 상태
   - 따라서 영속성 컨텍스트가 제공하는 기능을 사용하지 못한다.
 2-2. 준영속 엔티티를 수정하는 2가지 방법
   - 병합(merge)사용
   - 변경 감지 기능 사용 
 2-3. 병합(merge) 동작 방식 
   1. merge()를 실행한다.
   2. 파라미터로 넘어온 준영속 엔티티의 식별자값으로 1차 캐시에서 엔티티 조회
     2-1. 만약 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고, 1차 캐시에 저장한다.
   3. 조회한 영속 엔티티에 member엔티티의 값을 채워넣는다. 
      (member엔티티의 모든 값을 mergeMember에 밀어 넣는다. 이때 name에 null 값도 밀어 넣는다.)
   4. 영속 상태인 mergeMember를 반환한다. 
      즉, merge는 1차 캐시에 있는 모든 내용을 바꿔 버리기 때문에, 특정 값에 대한 수정을 원치않는 경우엔 그 값이 null로 처리가 된다.
   결론 : 변경을 원치 않는 값의 경우 내가 set을 해주지 않으면 해당 값이 null로 update가 된다.
           필요한 값만 update를 원한다면 변경감지를 해주어야 한다. 
           즉, merge 코드는 실무에서 절대 쓰지 않는 사용법이라고 보면된다. (데이터가 날아갈 위험이 있기 때문이다.)
 2-4. 엔티티를 변경할 때는 항상 변경 감지를 이용
   - 트랜잭션이 있는 서비스 계층에 식별자(id)와 변경할 데이터를 명확하게 전달(파라미터 or dto)
   - 트랜잭션이 있는 서비스 계층에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경
   - 트랜잭션 커밋 시점에 변경 감지가 실행