1. intercepteptor
 - addInterceptor(new LogInterceptor()) : 인터셉터를 등록
 - order(1) : 인터셉터의 호출 순서를 지정. 낮을 수록 먼저 호출 된다.
 - addPathPatterns("/**") : 인터셉터를 적용할 URL 패턴을 지정한다. 
 - excludePathPatterns("/css/**", "/*.ico", "/error") : 인터셉터에서 제외할 패턴을 지정

2. 스프링 URL 경로
 - https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/util/pattern/PathPattern.html
 - 스프링이 제공하는 URL 경로는 서블릿 기술이 제공하는 URL 경로와 완전히 다르다.
 - 더욱 자세하고, 세밀하게 설정할 수 있다.

3. JPA
 3-1. JPA란
   - JPA는 기존의 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행해 준다.
   - JPA를 사용하면, SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임을 전환 할 수 있다.
   - JPA를 사용하면 개발 생산성을 크게 높일 수 있다.
   - Spring 만큼이나 큰 기술
 3-2. ORM
   - JPA(Java Persistence API)는 자바 진영에서 ORM(Object-Relational Mapping) 기술 표준으로 사용되는 인터페이스의 모음이다.
   - 그 말인 즉, 실제적으로 구현된 것이 아니라 구현된 클래스와 매핑을 해주기 위해 사용되는 프레임워크다.
   - JPA를 구현한 대표적인 오픈소스로는 Hibernate가 있다. (JPA는 표준 인터페이스, 구현체가 Hibernate이다.)
 3-3. ORM
   - Object-Relational Mapping(객체 관계 매핑)
   - 객체는 객체대로 설계
   - 관계형 데이터베이스는 관계형 데이터베이스대로 설계
   - ORM프레임워크가 중간에서 매핑
   - 즉, 우리가 일반 적으로 알고있는 애플리케이션 Class와 RDB(Relational Database)의 테이블을 매핑(연결) 한다는 뜻이며, 기술적으로는 어플리케이션의 객체를 RDB테이블에 자동으로 영속화 해주는 것이라고 보면 된다.
 3-4. JPA 장점
   - SQL문이 아닌 Method를 통해서 DB를 조작할 수 있어, 개발자는 객체 모델을 이용하여 비즈니스 로직을 구성하는데만 집중할 수 있다.
     (내부적으로는 쿼리를 생성하여 DB를 조작함. 하지만 개발자가 이를 신경 쓰지 않아도 됨)
   - Query와 같이 필요한 선언문, 할당 등의 부수적인 코드가 줄어들어, 각종 객체에 대한 코드를 별도로 작성하여 코드의 가독성을 높임
   - 객체지향적인 코드 작성이 가능하다.
     오직 객체지향적 접근만 고려하면 되기 때문에 생산성 증가
   - 매핑하는 정보가 class로 명시되었기 때문에 ERD를 보는 의존도를 낮출 수 있고, 유지보수 및 리팩토링에 유리하다.
   - 기존 방식에서 Oracle 데이터베이스를 사용하다가 PostgreSql로 변환한다고 가정하면, 새로 쿼리를 짜야하는 경우가 생김.
     이런 경우에 ORM을 사용한다면 쿼리를 수정할 필요가 없다.
 3-5. 단점
   - 프로젝트의 규모가 크고 복잡하여 설계가 잘못된 경우, 속도 저하 및 일관성을 무너뜨리는 문제점이 생길 수 있다.
   - 복잡하고 무거운 Query는 속도를 위해 별도의 튜닝이 필요하기 때문에 결국에는 SQL문을 써야할 수도 있다.
   - 학습비용이 비쌈

4. 데이터베이스 방언
 - JPA는 특정 데이터베이스 종속 X
 - 각각의 데이터베이스가 제공하는 SQL문법과 함수는 조금씩 다름
 - 가변문자 : MySQL varchar, Oracle varchar2
 - 방언 : SQL표준을 지키지 않는 특정 데이터베이스의 고유한 기능
 - oracle 이라는 사투리를 써서 쿼리를 작성해 라는 뜻

5. JPA 기능
 - 객체와 테이블을 생성하고 매핑
 - @Entity : JPA가 관리할 객체
 - @id : 데이터베이스 PK와 매핑

6. JPA 설정
 - hibernate.hbm2ddl.auto = ...
	-> 데이터베이스 초기화 전략 설정
	none : 아무것도 실행하지 않음
	create : 시작될때 기존테이블 삭제 후 다시 생성 // 수업시간에서만 사용해야 함. 절대 프로젝트에서 사용 X
	create-drop : create와 같으나, 종료될 때 drop을 실행 // 수업시간에서만 사용해야 함. 절대 프로젝트에서 사용 X
	update : 변경된 스키마만 반영
	validate : 엔티티와 테이블이 정상적으로 매핑되었는지만 확인한다.

7. 엔티티 매니저
 - 엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유
 - JPA의 모든 데이터 변경은 트랜잭션 안에서 실행

8. JPQL
 - JPA를 사용하면 엔티티 객체를 중심으로 개발
 - 문제는 검색 쿼리
 - 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
 - 모든 DB데이터를 객체로 변환해서 검색하는 것은 불가능
 - 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요
 - JPA는 SQL을 추상화한 JPQL이라는 객체 지향 쿼리 언어 제공
 - SQL과 유사한 문법, select, from, where, group by, having, join 지원
 - SQL은 데이터베이스 테이블을 대상으로 쿼리 작성
 - JPQL은 엔티티 객체를 대상으로 쿼리 작성
 - 즉, 한마디로 정의하면 객체 지향 SQL

9. 영속성 컨텍스트
 9-1. 엔티티 매니저 팩토리와 엔티티 매니저
 9-2. 영속성 컨텍스트
   - JPA를 이해하는데 가장 중요한 용어
   - "엔티티를 영구 저장하는 환경"이라는 뜻
   - em.persist(entity);
	-> entity에 들어가는 객체(Member, ... 등)를 DB에 저장하는 구나.. 싶은데 좀 더 깊은 의미가 있다.
	-> 처음부터 DB에 저장하는게 아니라 영속성 컨텍스트라는 곳에 저장한다.
   - 영속성 컨텍스트는 논리적인 개념
   - 눈에 보이지 않는다.
   - 엔티티 매니저를 통해서 영속성 컨텍스트에 접근
   - 엔티티 매니저를 생성하면 영속성 컨텍스트가 생성이 된다. 
 9-3. 엔티티의 생명주기
   - 비영속(new/transient)
	-> 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
   - 영속(managed)
	-> 영속성 컨텍스트한테 관리되는 상태
   - 준영속(detached)
	-> 영속성 컨텍스트에 저장되었다가 분리된 상태
   - 삭제(removed)
	-> 삭제된 상태
 9-4. 비영속 - JPA와 전혀 상관 없는 상태
   - 객체를 생성한 상태(비영속)
	Member m = new Member();
	member.setId("member1");
	member.setUsername("회원1");
 9-5. 영속 - JPA에 속해있는 상태
	Member m = new Member();
	member.setId("member1");
	member.setUsername("회원1");
	//객체를 저장한 상태(영속)
	em.persist(member);
 9-6. 준영속
   - 회원 엔티티를 영속성 컨텍스트에서 분리, 준영속 상태
	em.detach(member);
 9-7. 삭제
   - 객체 삭제를 요청한 상태
	em.remove(member);