1. 예외처리
 1-1. 에러의 종류
   - 컴파일 에러
	-> 소스코드의 구문 오류로 인하여 컴파일이 불가능한 상태
	-> 이클립스에서 빨간색으로 표시되는 경우에 해당한다.
	-> 프로그램을 실행하기 전에 발견되므로 상대적으로 고치기 쉽다.
   - 런타임 에러
	-> 구문상의 에러는 없지만, 프로그램이 실행되는 과정에서 다양한 경우의 수에 대응하지 못하여 발생하는 예외상황
	-> 런타임에러가 발생하면 프로그램은 강제로 종료된다.
	-> 우리가 프로그램의 에러라고 부르는 현상은 대부분 런타임 에러에 해당한다.
 1-2. 런타임 에러의 종류
   - 런타임 에러는 프로그램 자체의 구조적인 문제로 인한 논리적 오류와 자바 가상머신 자체의 문제로 인한 오류, 그리고 예외가 있다.
   - 논리오류
	-> 논리적 모순이 생기지 않도록 코드를 작성해야 한다.
   - 자바 가상 머신 자체 오류
	-> 프로그래머가 책임질 수 있는 수준의 오류가 아니다.
   - 예외(Exception)
	-> 프로그램 실행 중에 발생할 수 있는 예기치 않은 사건으로, 프로그래머의 노력으로 처리할 수 있다. 
	-> 자바 가상머신은 프로그램 실행중에 예외가 발생하면 관련된 예외 클래스로부터 예외 객체를 생성하여 프로그램에서 지정된 예외 처리 구문으로 넘긴다.
	-> 예외가 발생하면 프로그램에 지정된 예외 처리 구문이 자바 가상머신에 의해 호출되고, 이때 전달되는 예외 객체를 넘겨받아 적절한 처리를 수행한다.
 1-3. java의 예외처리
   - java에서는 try ~ catch ~ finally 구문을 통해 프로그래머가 예외 상황에 대응할 수 있도록 하고 있다. 
	try{
		// 기본적으로 실행되는 부분
	} catch(예외클래스이름 객체 이름) {
		// try 블록에서 예외가 발생한 경우
		// 이 곳으로 제어가 넘어온다. 
	} finally {
		// 예외 상황의 발생 여부에 상관 없이
		// 무조건 실행되는 부분
		// finally 블록은 생략 가능하다.
	}
   - try 블록 실행도중 catch에서 명시한 예외 클래스에 해당하는 런타임 에러가 발생하면, try 블록을 즉시 중단하고 catch 블록이 실행 된 후, finally 블록이 실행된다.
   - 예외가 발생하지 않을 경우 try 블록 종료 후 finally 블록이 실행된다.
 1-4. catch블록을 사용한 복합 에러 처리
   - catch 블록은 에러가 예상되는 상황에 대해 복수로 명시하는 것이 가능하다.
 1-5. Exception 클래스
   - java에서 예외 상황을 의미하는 모든 클래스들의 최상위 클래스
   - 이 클래스의 이름으로 catch 블록을 구성하면, 모든 예외 상황에 일괄적으로 대응할 수는 있지만, catch 블록이 세분화 된 경우와는 달리 상황 별 개별적인 처리는 불가능하다. 
   - Exception 클래스에 대한 예외처리는 대부분 맨 마지막 catch 블록에 명시하여 '마지막 알 수 없는 에러'를 의미하도록 구성한다.
	try {
		...실행할 구문...
	} catch(NumberFormatException e) {
		...실행할 구문...
	} catch(ArrayIndexOutOfBoindsException e) {
		...실행할 구문...
	} catch(Exception e) {
		...실행할 구문...
	}
 1-6. 에러 객체 'e'의 기능
   - e.getMessage()
	-> 간략한 에러 메시지를 리턴한다.
	-> e.getLocalisedMessage() 도 같은 기능을 한다.
   - e.pristStackTrace()
	-> 실제 예외 상황시에 출력되는 메시지를 강제로 출력한다.
	-> 개발자가 catch 블록 안에서 예외 상황을 분석하기 위한 용도로 사용한다.

2. Calendar

3. 컬렉션 프레임워크(Collection Framework)
 3-1. Collection Framework란
  - 다수의 데이터를 쉽게 처리할 수 있는 표준화된 방법을 제공하는 클래스들로, 기존 배열형태의 자료 저장에서 좀 더 다양한 데이터들을 저장하기 위한 필수 클래스이다.

 3-2. Collection Framework 종류

 3-3. HashMap 클래스
  - 데이터에 이름표를 적용하여 저장하기
  - HashMap 클래스는 Map 인터페이스를 상속받는 '자료 보관소'이기 때문에, 암묵적 객체 형변환의 규칙에 따라 Map 형태로 선언하고 HashMap 형태로 할당
  - 선언과 할당시에 HashMap의 이름표로 사용할 데이터형(String)과 HashMap에 저장할 데이터형을 클래스의 이름으로 명시해야 하는데, 이를 '제너릭스'라 한다. 
  - 제너릭스에 명시할 수 있는 데이터형은 반드시 클래스 이름이여야 하기 때문에 기본 자료형을 보관할 경우 Wrapper 클래스의 이름을 사용한다.
	Map<String, 저장할 데이터의 클래스이름> data
	= new HashMap<String, 저장할 데이터의 클래스이름>();

  - 기존에 저장된 데이터와 중복되는 이름이 저장될 경우, 기존에 저장된 데이터를 덮어 씌우게 된다. 
