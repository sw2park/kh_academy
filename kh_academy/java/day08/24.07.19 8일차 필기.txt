1. Override
 1-1. 오버라이드란 (신입 기술 면접시 많이 나오는 내용)
   - 부모 클래스에 정의된 것과 동일한 이름을 갖는 
     메서드를 자식 클래스가 정의한 경우,
     부모 클래스의 기능은 자식에게 가려진다.
   - 이렇게 부모의 기능을 재정의 하는 것을 메서드 Override라 한다.
 1-2. 하나의 이름으로 다양한 효과 얻기
   - 모든 자식 클래스가 동일한 이름의 메서드를 갖게되므로 
     각 객체에 대하여 attack()이라는 이름을 사용하여 서로 다른 형태를 구현할 수 있게 된다.

2. super 키워드
 - 클래스의 상속관계에서 자식 클래스가 부모클래스를 가리키는 예약어
 2-1. 사용방법
   - 멤버면수 이름 앞에 명시
	-> 부모 클래스의 멤버변수를 의미한다.
	    하지만 부모클래스의 멤버변수는 의미 모두 상속되어 있기 때문에 
	    이 경우에는 this 키워드를 사용하는 것과 동일한 결과이기에 잘 사용하지 않는다.
   - 메서드 이름앞에 명시하는 경우
	-> 부모 클래스의 메서드를 의미
	-> 재정의 되지 않는 메서드 : 이미 상속되어 있기 때문에 this키워드를 
	    사용하는 것과 동일한 결과를 갖는다.
	-> 재정의 된 메서드 : 
	Override된 메서드 이름 앞에 사용하게 되면 재정의 되기 이전의 원본 메서드를 의미한다.
	-> 키워드 자체를 메서드처럼 사용
		-> 부모 클래스의 생성자를 의미한다.
 2-2. 상속을 통한 메서드의 기능확장 처리
   - Hello클래스가 Korean에 상속되고, Korean클래스가 say() 메서드를 
     Override 처리하게 되면 Korean 클래스의 객체는 더 이상 
     부모의 say() 메서드에 접근할 수 없게 된다.
   - 만약 부모 클래스가 가지고 있는 say() 메서드에 추가적인 기능을 구현하고자 한다면
     부모의 코드를 그대로 복사해서 사용해야 할 것이다.
   - 원본 기능에 대한 수정이 발생할 경우 부모클래스와 자식 클래스를 모두 수정해야 하기 때문에
     소스코드의 유지보수 효율성이 떨어지게 된다. 
   - super키워드는 부모 클래스의 메서드를 호출하는 기능을 가지고 있기 때문에
     Override된 자식 클래스이 메서드에서 super 키워드를 사용하면,
     재정의 되기 이전의 부모 클래스에 대한 메서드를 호출할 수 있다.
   - super키워드를 사용하여 부모의 메서드를 호출한 뒤에 추가적인 기능을 정의하고 있으므로,
     부모의 원본 메서드에 대한 기능확장 효과가 있다.
 2-3. 상속 관계에서의 생성자 처리
   - 생성자가 정의된 클래스의 상속 제한
   - 생성자는 상속되지 않는다.
   - 하지만 생성자가 정의된 클래스는 객체 생성을 위해서 생성자 파라미터를 반드시 전달받아야 하기 때문에,
     파라미터를 갖는 생성자가 정의된 클래스를 상속받게 되면 에러가 발생한다.

3. @Override 옵션
 - 메서드 재정의 과정에서 오타가 발생한 경우
 - 부모클래스의 say() 메서드를 재정의 하는 과정에서 개발자의 실수로 인해 "say()"라고
   메서드가 추가되었다면 java는 새로운 메서드를 추가한 것으로 인식하고, 특별한 에러표시를 하지않는다.
 - 메서드 재정의 과정에서의 오타 방지 옵션
 - @Override는 이 키워드가 명시된 위치 아래에 정의되는 메서드가 부모클래세으 존재하지 않을 경우
   구문 에러로 처리한다.
 - 부모클래스의 메서드를 재정의 하고자 할 경우 의도치 않은 실수를 예방하기 위한 '오타 방지 옵션'이다.
 - 여러 개의 메서드를 재정의 한다면 재정의 되는 모든 메서드들 위에 각기 명시해야 한다.

4. 메서드 오버로드
 4-1. 메서드 오버로드란?
   - 원칙적으로 하나의 클래스 안에서는 동일한 이름의 메서드가 두 개 이상 존재할 수 없지만,
     이를 가능하게 하는 예외적인 처리 기법
 4-2. 이름이 동일한 메서드를 정의하기 위한 조건
   - 메서드간의 파라미터가 서로 달라야 한다.
	-> 파라미터의 데이터 타입이 다르다
	(데이터 형이 동일하고 변수의 이름이 다른 경우는 동일한 파라미터로 인식된다.)
   - 파라미터의 개수가 다른경우
   - 서로 다른 데이터형을 갖는 파라미터들의 전달 순서가 다르다. 
   - 리턴형이 다른 경우는 오버로의 성립에 아무런 영향을 주지 않는다.
 4-3. 메서드 오버로드 예시
   - 파라미터의 데이터 형이 서로 다르기 때문에 오버로드 성립
   public void plus(int a){}
   public void plus(boolean a){}
   - 파라미터의 개수가 서로 다르기 때문에 오버로드 성립
   public void user(int a){}
   public void use(int a, int b){}
   - 데이터형의 전달 순서가 서로 다르기 때문에 오버로드 성립
   public void user(int a, boolean b){}
   public void user(boolean a, int b){}
   - 오버로드 성립 불가
   public void user(int a){}
   public void user(int b){}
 4-4. 오버로드 사용 이유
   - 오버로드는 하나의 메서드를 호출할 수 있는 모든 경우의 수를 미리 준비해 놓음으로서,
     메서드를 만드는 측은 번거로울 수 있지만 메서드를 호출하는 측은 데이터 타입을
     신경쓰지않고 편리하게 사용할 수 있게 하기 위함이다.
 4-5. 객체 생성 방법의 다양화
   - 생성자 역시 메서드의 한 종류이므로 Overload가 가능하다.
   - 생성자를 Overload 할 경우, 해당 클래스에 대해 '객체 생성하는 방법'을
     다양하게 준비할 수 있게 된다.
 4-6. this 키워드를 사용한 생성자 Overload
   - this 키워드의 용법
	-> 메서드처럼 사용할 경우, 현재 클래스의 다른 생성자를 의미
   - this 키워드를 사용하여 생성자 Overload를 간결하게 처리하기
	-> 파라미터가 서로 다른 생성자들이 하나의 완전한 생성자를 호출하도록 하여,
	    데이터의 초기화를 한 곳에서 일괄적으로 처리하도록 구현할 수 있다.

5. 객체 형변환
 5-1. 객체 형변환
   -  java 기본 유형의 데이터들처럼 객체 참조변수의 경우에도 형변환(casting)이 이루어진다.
   - 서로 다른 클래스 유형으로부터 나온 객체 참조변수들 간의 대입에는 일정한 규칙이 있다.
	Parent p = new Child();
   - 왼쪽 항(Parent)과 오른쪽 항(Child)의 객체 유형이 서로 다른 경우, 두 유형이 서로 상속관계에 있고
     왼쪽 객체(Parent)가 오른쪽 개체(Child)의 상위 클래스인 경우에만 암묵적 형변환이 일어난다.
   - 하위클래스에서 상위클래스 유형으로 할당하는 것은 가능하나, 그 경우에는 명시적 형변환을 해야한다.
 5-2. 객체간의 암묵적 형변환
   암묵적 형변환
   ------------------------
   C c = new C();
   B b2 = c;
   ------------------------
   Y y = new Y();
   X x2 = y;
   ------------------------
 5-3. 암묵적 형변환과 메서드 오버라이드
   - 암묵적 형변환은 부모를 상속받는 자식객체의 기능을 부모에게 물려받은 기능만 사용하도록 제한한다.
   - 그러므로 암묵적 형변환이 발생하게 되면 오버라이드된 기능만 사용가능하고, 추가적으로 구현한 기능은 사용할 수 없다.
   - 주의할 점은 기능의 제한이지 기능의 변경은 아니라는 것.
 - 상속관계의 객체를 부모 형태로 변환하면 클래스의 종류를 구분하지 않고 일관된 기능을 호출할 수 있고, 
 객체가 상위 클래스형태로 형변환 되더라도 Override된 자신의 기능은 잃지않는다.
	Unit u1 = new Army();
	Unit u2 = new Navy();
	Unit u3 = new AirForce();

	u1.attack();
	u2.attack();
	u3.attack();
 - 하지만, 추가적으로 구현한 기능은 사용할 수 없게 되므로, 원래의 기능을 다시 사용할 수 있는 방법이 필요해졌다.
 5-4. 명시적 형변환
   - 부모 클래스의 객체를 자식 클래스 형태로 변환하는 것
   - 형변환을 위해서는 다음과 같이 변환할 클래스 이름을 명시적으로 지정해 주어야 한다.
	ChildClass child =(ChildClass)parent;
 5-5. 명시적 형변환의 조건
   - 객체가 최초 생성될 때 자식 클래스 형태로 생성되고, 부모 형태로 암묵적 형변환이 된 상태를 다시 원래의 자식 클래스 형태로 되돌릴
     경우에만 가능하다.
	ChildClass child1 = new ChildClass();
	ParentClass parent = child1;	// 암묵적 형변환
	ChildClass child2 = (ChildClass)parent; // 명시적 형변환
   - 가능한 경우 : new로 할당된 원본 클래스로 되돌아가는 경우에만 가능
             ------------------------------------------------
	Army army1 = new Army();
	Unit u = army1;
	Army army2 = (Army)u;
             ------------------------------------------------
	Unit u = new Navy();
	Navy navy = (Navy)u;
   - 최초 객체 생성이 부모 형태로 만들어진 경우 불가능 
	Unit u = new Unit();
	Army army = (Army)u;
   - 최초 생성된 것과 다른 형식으로 변환하는 것은 불가능하다.
	Army army = new Army();
	Unit u = army;
	Navy navy = (Navy)u;
 - 위의 두 경우 모두 문법적인 오류는 없기 때문에, 이클립스에서는 에러를 검출하지 못한다.
   하지만, 프로그램을 실행시켰을 경우에는 에러가 발생한다.